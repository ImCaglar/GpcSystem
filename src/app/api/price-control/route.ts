import { NextRequest, NextResponse } from 'next/server'
import { supabaseAdmin } from '@/lib/supabase'
import { auditLogger, extractUserInfo } from '@/lib/audit'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
export const revalidate = 0

interface InvoiceProduct {
  id: string
  product_code: string  // tedarikci_stok_kodu
  product_name: string  // urun_adi
  unit_price: number    // birim_fiyati
  quantity: number      // miktar
  unit: string         // birim
  total_amount: number // toplam tutar
  invoice_summary?: {
    invoice_number: string
    invoice_date: string
  }
}

interface StockMapping {
  tedarikci_malzeme_kodu: string  // Excel'den gelen kod
  ikinci_kalite_no: string        // ic_stok_kodu
  ikinci_item_number: string      // ic_urun_adi
}

interface TutedPrice {
  product_name: string
  list_price: number
  price_date: string
}

interface AbbPrice {
  product_name: string
  max_price: number // Doƒüru kolon adƒ±
}

interface PriceControlResult {
  invoice_product: InvoiceProduct
  stock_mapping?: StockMapping
  tuted_price?: TutedPrice
  abb_price?: AbbPrice
  normalized_product_name: string
  tuted_discounted_price?: number  // TUTED fiyat √ó 0.32
  abb_markup_price?: number       // ABB max fiyat √ó 1.10
  tuted_rule_violated: boolean    // birim_fiyati > tuted_fiyat √ó 0.32
  abb_rule_violated: boolean      // birim_fiyati > abb_max_price √ó 1.10
  refund_required: boolean        // Her iki kural da ihlal edildi mi?
  refund_amount: number          // fatura_fiyati - (abb_max_price √ó 1.10)
  warning_only: boolean          // Sadece bir kural ihlal edildi mi?
  price_difference: number       // Fark miktarƒ±
  status: 'COMPLIANT' | 'WARNING' | 'REFUND_REQUIRED' | 'PENDING_MANUAL_REVIEW'
  needs_manual_review?: boolean   // Manuel onay gerekli mi?
  problem_type?: string          // Hangi t√ºr problem var?
  confidence_details?: {         // Problem detaylarƒ±
    analysis: string
  }
}

// Geli≈ümi≈ü √ºr√ºn adƒ± normalizasyonu
function normalizeProductName(name: string): string {
  return name
    .toLowerCase()
    .trim()
    // T√ºrk√ße karakterleri d√∂n√º≈üt√ºr
    .replace(/[√ß√á]/g, 'c')
    .replace(/[ƒüƒû]/g, 'g') 
    .replace(/[ƒ±ƒ∞I]/g, 'i')
    .replace(/[√∂√ñ]/g, 'o')
    .replace(/[≈ü≈û]/g, 's')
    .replace(/[√º√ú]/g, 'u')
    // √ñzel karakterleri ve fazla bo≈üluklarƒ± temizle
    .replace(/[^\w\s]/g, ' ')           // √ñzel karakterleri bo≈ülukla deƒüi≈ütir
    .replace(/\s+/g, ' ')               // √áoklu bo≈üluklarƒ± tek bo≈üluk yap
    .replace(/\b(kg|gr|adet|lt|litre|paket|pk)\b/g, '') // Birim kelimelerini kaldƒ±r
    .trim()
    .replace(/\s+/g, '_')               // Bo≈üluklarƒ± alt √ßizgi yap
}

// Fuzzy matching i√ßin Levenshtein distance
function calculateSimilarity(str1: string, str2: string): number {
  const matrix: number[][] = []
  const len1 = str1.length
  const len2 = str2.length

  if (len1 === 0) return len2
  if (len2 === 0) return len1

  // Initialize matrix
  for (let i = 0; i <= len1; i++) {
    matrix[i] = [i]
  }
  for (let j = 0; j <= len2; j++) {
    matrix[0][j] = j
  }

  // Fill matrix
  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,     // deletion
        matrix[i][j - 1] + 1,     // insertion
        matrix[i - 1][j - 1] + cost // substitution
      )
    }
  }

  const distance = matrix[len1][len2]
  const maxLength = Math.max(len1, len2)
  return maxLength === 0 ? 1 : (maxLength - distance) / maxLength
}

// Optimized product matching with caching and confidence scoring
class ProductMatcher {
  private mappingCache: Map<string, string> = new Map()
  private normalizedCache: Map<string, string> = new Map()
  private unmatchedProducts: Array<{source_system: string, source_name: string, normalized_name: string}> = []
  private confidenceThreshold = 0.85 // %85 g√ºven e≈üiƒüi

  constructor(private mappings: any[]) {
    this.buildCache()
  }

  private buildCache() {
    console.log('üîÑ Product mapping cache olu≈üturuluyor...')
    
    for (const mapping of this.mappings) {
      const normalizedKey = mapping.normalized_key
      
      // Gloria mappings
      if (mapping.gloria_name) {
        const key = `gloria:${mapping.gloria_name.toLowerCase()}`
        this.mappingCache.set(key, normalizedKey)
      }
      
      // TUTED mappings
      if (mapping.tuted_name) {
        const key = `tuted:${mapping.tuted_name.toLowerCase()}`
        this.mappingCache.set(key, normalizedKey)
      }
      
      // ABB mappings
      if (mapping.abb_name) {
        const key = `abb:${mapping.abb_name.toLowerCase()}`
        this.mappingCache.set(key, normalizedKey)
      }

      // Alternative names
      if (mapping.alternative_names && Array.isArray(mapping.alternative_names)) {
        for (const altName of mapping.alternative_names) {
          const key = `alt:${altName.toLowerCase()}`
          this.mappingCache.set(key, normalizedKey)
        }
      }
    }
    
    console.log(`‚úÖ Cache olu≈üturuldu: ${this.mappingCache.size} mapping`)
  }

  // Yeni g√ºvenilir e≈üle≈ütirme metodu
  findMatchWithConfidence(productName: string, sourceSystem: 'gloria' | 'tuted' | 'abb' = 'gloria'): {
    match: string | null,
    confidence: number,
    strategy: string,
    suggestions: string[]
  } {
    try {
      if (!productName || typeof productName !== 'string') {
        return { match: null, confidence: 0, strategy: 'empty', suggestions: [] }
      }
      
      const cleanName = productName.trim()
      const lowerName = cleanName.toLowerCase()
      
      // 1. Kesin e≈üle≈ütirme (Confidence: 1.0)
      const mappingKey = `${sourceSystem}:${lowerName}`
      if (this.mappingCache.has(mappingKey)) {
        return {
          match: this.mappingCache.get(mappingKey)!,
          confidence: 1.0,
          strategy: 'exact_mapping',
          suggestions: []
        }
      }

      // 2. Alternatif isim e≈üle≈ütirmesi (Confidence: 0.95)
      const altKey = `alt:${lowerName}`
      if (this.mappingCache.has(altKey)) {
        return {
          match: this.mappingCache.get(altKey)!,
          confidence: 0.95,
          strategy: 'alternative_name',
          suggestions: []
        }
      }

      // 3. Normalle≈ütirilmi≈ü e≈üle≈ütirme
      const normalized = this.normalize(cleanName)
      
      // 4. √áoklu strateji fuzzy matching
      const fuzzyResults = this.advancedFuzzyMatch(normalized, cleanName)
      
      if (fuzzyResults.length > 0) {
        const bestMatch = fuzzyResults[0]
        
        if (bestMatch.confidence >= this.confidenceThreshold) {
          return {
            match: bestMatch.key,
            confidence: bestMatch.confidence,
            strategy: bestMatch.strategy,
            suggestions: fuzzyResults.slice(1, 4).map(r => r.original) // En iyi 3 alternatif
          }
        } else {
          // D√º≈ü√ºk g√ºvenilirlik - √∂neriler sun
          return {
            match: null,
            confidence: bestMatch.confidence,
            strategy: 'low_confidence',
            suggestions: fuzzyResults.slice(0, 5).map(r => r.original)
          }
        }
      }

      // 5. E≈üle≈ütirme bulunamadƒ±
      if (sourceSystem === 'gloria') {
        this.unmatchedProducts.push({
          source_system: sourceSystem,
          source_name: cleanName,
          normalized_name: normalized
        })
        console.log(`‚ùå Gloria √ºr√ºn√º e≈üle≈ütirilemedi: "${cleanName}"`)
      }
      
      return {
        match: null,
        confidence: 0,
        strategy: 'no_match',
        suggestions: this.getSimilarProductSuggestions(normalized)
      }
      
    } catch (error) {
      console.error('‚ùå findMatchWithConfidence hatasƒ±:', error)
      return {
        match: null,
        confidence: 0,
        strategy: 'error',
        suggestions: []
      }
    }
  }

  // Geriye uyumluluk i√ßin eski metod
  findMatch(productName: string, sourceSystem: 'gloria' | 'tuted' | 'abb' = 'gloria'): string {
    const result = this.findMatchWithConfidence(productName, sourceSystem)
    return result.match || this.normalize(productName)
  }

  private normalize(name: string): string {
    if (this.normalizedCache.has(name)) {
      return this.normalizedCache.get(name)!
    }

    const result = name
      .toLowerCase()
      .trim()
      // T√ºrk√ße karakterleri d√∂n√º≈üt√ºr
      .replace(/[√ß√á]/g, 'c')
      .replace(/[ƒüƒû]/g, 'g') 
      .replace(/[ƒ±ƒ∞I]/g, 'i')
      .replace(/[√∂√ñ]/g, 'o')
      .replace(/[≈ü≈û]/g, 's')
      .replace(/[√º√ú]/g, 'u')
      // Parantez i√ßindeki bilgileri kaldƒ±r
      .replace(/\([^)]*\)/g, '')
      // √ñzel karakterleri ve fazla bo≈üluklarƒ± temizle
      .replace(/[^\w\s]/g, ' ')
      .replace(/\s+/g, ' ')
      // Birim kelimelerini kaldƒ±r
      .replace(/\b(kg|gr|gram|adet|lt|litre|liter|paket|pk|piece|pcs)\b/g, '')
      // Sƒ±k kullanƒ±lan kelimeler
      .replace(/\b(fresh|taze|organic|organik|premium|kalite|quality)\b/g, '')
      .trim()
      .replace(/\s+/g, '_')

    this.normalizedCache.set(name, result)
    return result
  }

  private advancedFuzzyMatch(normalized: string, original: string): Array<{
    key: string,
    original: string,
    confidence: number,
    strategy: string
  }> {
    const results: Array<{key: string, original: string, confidence: number, strategy: string}> = []
    const allNormalizedKeys = [...new Set(this.mappingCache.values())]
    
    for (const key of allNormalizedKeys) {
      // Strateji 1: Tam normalize e≈üle≈ütirme
      if (key === normalized) {
        results.push({
          key,
          original: this.getOriginalName(key),
          confidence: 0.9,
          strategy: 'normalized_exact'
        })
        continue
      }
      
      // Strateji 2: Substring e≈üle≈ütirme
      const substringScore = this.calculateSubstringScore(normalized, key)
      if (substringScore > 0.7) {
        results.push({
          key,
          original: this.getOriginalName(key),
          confidence: substringScore * 0.85,
          strategy: 'substring_match'
        })
        continue
      }
      
      // Strateji 3: Kelime bazlƒ± e≈üle≈ütirme
      const wordScore = this.calculateWordBasedScore(normalized, key)
      if (wordScore > 0.6) {
        results.push({
          key,
          original: this.getOriginalName(key),
          confidence: wordScore * 0.8,
          strategy: 'word_based'
        })
        continue
      }
      
      // Strateji 4: Levenshtein distance
      const similarityScore = this.calculateSimilarity(normalized, key)
      if (similarityScore > 0.5) {
        results.push({
          key,
          original: this.getOriginalName(key),
          confidence: similarityScore * 0.75,
          strategy: 'levenshtein'
        })
      }
    }
    
    // Confidence'a g√∂re sƒ±rala
    return results.sort((a, b) => b.confidence - a.confidence)
  }

  private calculateSubstringScore(str1: string, str2: string): number {
    const longer = str1.length > str2.length ? str1 : str2
    const shorter = str1.length > str2.length ? str2 : str1
    
    if (longer.includes(shorter)) {
      return shorter.length / longer.length
    }
    
    // Ortak substring'leri bul
    let maxCommonLength = 0
    for (let i = 0; i < shorter.length; i++) {
      for (let j = i + 1; j <= shorter.length; j++) {
        const substring = shorter.substring(i, j)
        if (longer.includes(substring) && substring.length > maxCommonLength) {
          maxCommonLength = substring.length
        }
      }
    }
    
    return maxCommonLength / longer.length
  }

  private calculateWordBasedScore(str1: string, str2: string): number {
    const words1 = str1.split('_').filter(w => w.length > 2)
    const words2 = str2.split('_').filter(w => w.length > 2)
    
    if (words1.length === 0 || words2.length === 0) return 0
    
    let matchingWords = 0
    for (const word1 of words1) {
      for (const word2 of words2) {
        if (word1 === word2 || word1.includes(word2) || word2.includes(word1)) {
          matchingWords++
          break
        }
      }
    }
    
    return matchingWords / Math.max(words1.length, words2.length)
  }

  private getOriginalName(normalizedKey: string): string {
    // Mapping'lerden orijinal adƒ± bul
    try {
      for (const mapping of this.mappings || []) {
        if (mapping?.normalized_key === normalizedKey) {
          return mapping.gloria_name || mapping.tuted_name || mapping.abb_name || normalizedKey
        }
      }
      return normalizedKey
    } catch (error) {
      console.error('‚ùå getOriginalName hatasƒ±:', error)
      return normalizedKey
    }
  }

  private getSimilarProductSuggestions(normalized: string): string[] {
    const suggestions: string[] = []
    const allNormalizedKeys = [...new Set(this.mappingCache.values())]
    
    for (const key of allNormalizedKeys) {
      const similarity = this.calculateSimilarity(normalized, key)
      if (similarity > 0.3) { // En az %30 benzerlik
        suggestions.push(this.getOriginalName(key))
      }
    }
    
    return suggestions.slice(0, 5) // En fazla 5 √∂neri
  }

  private calculateSimilarity(str1: string, str2: string): number {
    if (str1 === str2) return 1
    if (str1.length === 0 || str2.length === 0) return 0
    
    // Basitle≈ütirilmi≈ü benzerlik hesaplama
    const longer = str1.length > str2.length ? str1 : str2
    const shorter = str1.length > str2.length ? str2 : str1
    
    if (longer.length === 0) return 1
    
    const editDistance = this.levenshteinDistance(longer, shorter)
    return (longer.length - editDistance) / longer.length
  }

  private levenshteinDistance(str1: string, str2: string): number {
    const matrix: number[][] = []
    
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i]
    }
    
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j
    }
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1]
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          )
        }
      }
    }
    
    return matrix[str2.length][str1.length]
  }

     async saveUnmatchedProducts() {
     if (this.unmatchedProducts.length === 0) {
       console.log('‚úÖ T√ºm Gloria √ºr√ºnleri e≈üle≈üti!')
       return
     }
     
     try {
       console.log(`üíæ ${this.unmatchedProducts.length} e≈üle≈ümeyen Gloria √ºr√ºn√º kaydediliyor...`)
       
       // Sadece benzersiz √ºr√ºnleri kaydet
       const uniqueProducts = this.unmatchedProducts.filter((product, index, self) =>
         index === self.findIndex(p => p.source_name === product.source_name)
       )
       
       if (uniqueProducts.length > 0) {
         await supabaseAdmin
           .from('unmatched_products')
           .upsert(uniqueProducts.map(item => ({
             ...item,
             last_seen_at: new Date().toISOString()
           })), { 
             onConflict: 'source_system,source_name',
             ignoreDuplicates: false 
           })
           
         console.log(`‚úÖ ${uniqueProducts.length} benzersiz e≈üle≈ümeyen √ºr√ºn kaydedildi`)
       }
         
     } catch (error) {
       console.error('‚ùå Unmatched products kaydetme hatasƒ±:', error)
     }
   }
}

export async function GET() {
  return NextResponse.json({
    success: true,
    message: 'Fiyat Kontrol API - Hazƒ±r!',
    description: 'Excel e≈üleme ile TUTED/ABB fiyat kar≈üƒ±la≈ütƒ±rmasƒ±',
    timestamp: new Date().toISOString()
  })
}

export async function POST(request: NextRequest) {
  console.log('üéØ Fiyat Kontrol API Ba≈ülatƒ±ldƒ±')

  try {
    const body = await request.json()
    const { invoice_ids } = body

    if (!invoice_ids || !Array.isArray(invoice_ids) || invoice_ids.length === 0) {
      return NextResponse.json({ 
        error: 'Fatura ID\'leri gerekli (invoice_ids array)' 
      }, { status: 400 })
    }

    console.log(`üìã ${invoice_ids.length} fatura kontrol edilecek`)

    // 1. Faturalarƒ± getir (invoice_summary ile JOIN)
    const { data: invoiceProducts, error: invoiceError } = await supabaseAdmin
      .from('invoices')
      .select(`
        *,
        invoice_summary(invoice_number, invoice_date, id)
      `)
      .in('id', invoice_ids)

    if (invoiceError) {
      console.error('‚ùå Fatura getirme hatasƒ±:', invoiceError)
      return NextResponse.json({ error: 'Fatura verileri getirilemedi' }, { status: 500 })
    }

    console.log(`‚úÖ ${invoiceProducts.length} fatura √ºr√ºn√º getirildi`)
    
    // Fatura √ºr√ºn yapƒ±sƒ± kontrol edildi

    // 2. Excel verilerini getir (stock_mappings tablosundan - doƒüru tablo!)
    console.log('üìä Excel verilerini stock_mappings tablosundan getiriliyor...')
    const { data: excelMappings, error: excelError } = await supabaseAdmin
      .from('stock_mappings')
      .select('tedarikci_malzeme_kodu, ikinci_kalite_no, ikinci_item_number')
      .not('tedarikci_malzeme_kodu', 'is', null)
      .not('ikinci_item_number', 'is', null)

    if (excelError) {
      console.error('‚ùå Excel veri hatasƒ±:', excelError)
      return NextResponse.json({ error: 'Excel verileri getirilemedi' }, { status: 500 })
    }

    const stockMappings = excelMappings || []
    console.log(`‚úÖ ${stockMappings.length} Excel e≈üle≈ütirmesi getirildi`)

    // 3. TUTED fiyatlarƒ±nƒ± getir (doƒürudan DB'den)
    console.log('üõí TUTED fiyatlarƒ±nƒ± getiriliyor...')
    const { data: tutedPrices, error: tutedError } = await supabaseAdmin
      .from('tuted_prices')
      .select('product_name, unit_price, price_date')
      .order('price_date', { ascending: false })

    if (tutedError) {
      console.error('‚ùå TUTED fiyat hatasƒ±:', tutedError)
    }

    // En son fiyatlarƒ± al (unique product_name) ve list_price olarak rename et
    const uniqueTutedPrices = new Map()
    for (const price of tutedPrices || []) {
      const key = price.product_name
      if (!uniqueTutedPrices.has(key) || uniqueTutedPrices.get(key).price_date < price.price_date) {
        uniqueTutedPrices.set(key, {
          product_name: price.product_name,
          list_price: price.unit_price, // unit_price'ƒ± list_price olarak rename
          price_date: price.price_date
        })
      }
    }
    const tutedProductList = Array.from(uniqueTutedPrices.values())
    console.log(`‚úÖ ${tutedProductList.length} benzersiz TUTED fiyatƒ± getirildi`)

    // 3.5. TUTED √∂zel √ºr√ºn limitlerini getir
    console.log('üéØ TUTED √∂zel √ºr√ºn limitleri getiriliyor...')
    const { data: tutedSpecialLimits, error: specialLimitsError } = await supabaseAdmin
      .from('tuted_special_limits')
      .select('product_name, max_allowed_price')
      .eq('is_active', true)

    if (specialLimitsError) {
      console.error('‚ùå TUTED √∂zel limit hatasƒ±:', specialLimitsError)
    }

    // √ñzel limitleri Map'e √ßevir
    const specialLimitsMap = new Map()
    for (const limit of tutedSpecialLimits || []) {
      specialLimitsMap.set(normalizeProductName(limit.product_name), limit.max_allowed_price)
    }
    console.log(`‚úÖ ${tutedSpecialLimits?.length || 0} √∂zel TUTED limiti getirildi`)

    // 3.6. Product mapping verilerini getir ve matcher'ƒ± initialize et
    console.log('üîÑ Product mappings getiriliyor...')
    const { data: productMappings, error: mappingError } = await supabaseAdmin
      .from('product_name_mappings')
      .select('*')

    if (mappingError) {
      console.error('‚ùå Product mapping hatasƒ±:', mappingError)
    }

    // ProductMatcher'ƒ± initialize et
    const productMatcher = new ProductMatcher(productMappings || [])
    console.log(`‚úÖ ProductMatcher hazƒ±r: ${productMappings?.length || 0} mapping`)

    // 4. ABB fiyatlarƒ±nƒ± getir (doƒürudan DB'den)
    console.log('‚ö° ABB fiyatlarƒ±nƒ± getiriliyor...')
    const { data: abbPrices, error: abbError } = await supabaseAdmin
      .from('abb_prices')
      .select('product_name, max_price, scraped_date')
      .order('scraped_date', { ascending: false })

    if (abbError) {
      console.error('‚ùå ABB fiyat hatasƒ±:', abbError)
    }

    // En son fiyatlarƒ± al (unique product_name)
    const uniqueAbbPrices = new Map()
    for (const price of abbPrices || []) {
      const key = price.product_name
      if (!uniqueAbbPrices.has(key) || uniqueAbbPrices.get(key).scraped_date < price.scraped_date) {
        uniqueAbbPrices.set(key, price)
      }
    }
    const abbProductList = Array.from(uniqueAbbPrices.values())
    console.log(`‚úÖ ${abbProductList.length} benzersiz ABB fiyatƒ± getirildi`)

    // 5. √ñnceden onaylanmƒ±≈ü √ºr√ºnleri kontrol et (√á√ñZ√úM: Duplicate manual review √∂nleme)
    console.log('üîç √ñnceden onaylanmƒ±≈ü √ºr√ºnler kontrol ediliyor...')
    const { data: approvedProducts, error: approvedError } = await supabaseAdmin
      .from('price_comparisons')
      .select('invoice_number, tedarikci_stok_kodu, processed_by')
      .like('processed_by', 'manual_review_%')

    if (approvedError) {
      console.error('‚ùå Onaylanmƒ±≈ü √ºr√ºn kontrol√º hatasƒ±:', approvedError)
    }

    // Onaylanmƒ±≈ü √ºr√ºnleri Map'e √ßevir (hƒ±zlƒ± lookup i√ßin)
    const approvedProductsMap = new Map()
    for (const approved of approvedProducts || []) {
      const key = `${approved.invoice_number}-${approved.tedarikci_stok_kodu}`
      approvedProductsMap.set(key, true)
    }
    console.log(`‚úÖ ${approvedProducts?.length || 0} √∂nceden onaylanmƒ±≈ü √ºr√ºn bulundu`)

    // 6. Her fatura √ºr√ºn√º i√ßin kontrol yap
    const results: PriceControlResult[] = []

    for (const invoiceProduct of invoiceProducts) {
      console.log(`üîç Kontrol ediliyor: ${invoiceProduct.product_code} - ${invoiceProduct.product_name}`)

      // √á√ñZ√úM: Bu √ºr√ºn daha √∂nce manuel olarak onaylandƒ± mƒ± kontrol et
      const approvalKey = `${invoiceProduct.invoice_summary?.invoice_number}-${invoiceProduct.product_code}`
      const wasManuallyApproved = approvedProductsMap.has(approvalKey)
      
      if (wasManuallyApproved) {
        // Bu √ºr√ºn daha √∂nce manuel olarak onaylandƒ±
        results.push({
          invoice_product: invoiceProduct,
          normalized_product_name: normalizeProductName(invoiceProduct.product_name),
          tuted_rule_violated: false,
          abb_rule_violated: false,
          refund_required: false,
          refund_amount: 0,
          warning_only: false,
          price_difference: 0,
          status: 'COMPLIANT'
        })
        continue
      }

      // Stok e≈üle≈ütirmesi bul
      const stockMapping = stockMappings.find(
        mapping => mapping.tedarikci_malzeme_kodu === invoiceProduct.product_code
      )

      if (!stockMapping) {
        // Stok e≈üle≈ütirmesi bulunamadƒ±
        results.push({
          invoice_product: invoiceProduct,
          normalized_product_name: normalizeProductName(invoiceProduct.product_name),
          tuted_rule_violated: false,
          abb_rule_violated: false,
          refund_required: false,
          refund_amount: 0,
          warning_only: false,
          price_difference: 0,
          status: 'COMPLIANT'
        })
        continue
      }

      // Akƒ±llƒ± √ºr√ºn e≈üle≈ütirmesi (Optimized)
      const gloriaProductName = stockMapping.ikinci_item_number
      const normalizedProductName = productMatcher.findMatch(gloriaProductName, 'gloria')
      // Akƒ±llƒ± e≈üle≈ütirme yapƒ±ldƒ±

      // TUTED fiyatƒ± bul (g√ºvenilirlik sistemi ile - fallback ile)
      let tutedPrice = null
      let tutedMatchConfidence = 0
      let tutedMatchStrategy = ''
      let tutedSuggestions: string[] = []
      
      // TUTED e≈üle≈ütirmesi: Basit ve etkili
      for (const price of tutedProductList || []) {
        const tutedNormalized = productMatcher.findMatch(price.product_name, 'tuted')
        if (tutedNormalized === normalizedProductName) {
          tutedPrice = price
          tutedMatchConfidence = 0.9
          tutedMatchStrategy = 'normalized_match'
          break
        }
      }

      // ABB fiyatƒ± bul (g√ºvenilirlik sistemi ile - fallback ile)  
      let abbPrice = null
      let abbMatchConfidence = 0
      let abbMatchStrategy = ''
      let abbSuggestions: string[] = []
      
      // ABB e≈üle≈ütirmesi: Basit ve etkili
      for (const price of abbProductList || []) {
        const abbNormalized = productMatcher.findMatch(price.product_name, 'abb')
        if (abbNormalized === normalizedProductName) {
          abbPrice = price
          abbMatchConfidence = 0.9
          abbMatchStrategy = 'normalized_match'
          break
        }
      }

      // E≈üle≈ütirme sonu√ßlarƒ±nƒ± logla
              // Fiyat e≈üle≈ütirme sonucu belirlendi

      // Kural kontrol√º
      let tutedRuleViolated = false
      let abbRuleViolated = false
      let tutedDiscountedPrice: number | undefined
      let abbMarkupPrice: number | undefined

      // TUTED Kuralƒ±: √ñnce √∂zel limit kontrol et, yoksa normal %32 kuralƒ±
      if (tutedPrice) {
        const specialLimit = specialLimitsMap.get(normalizedProductName || '')
        
        if (specialLimit) {
          // √ñzel √ºr√ºn: Sabit maksimum fiyat kullan
          tutedDiscountedPrice = specialLimit
          tutedRuleViolated = invoiceProduct.unit_price > specialLimit
          console.log(`üéØ √ñZEL TUTED Kontrol: ${invoiceProduct.unit_price} > ${specialLimit} = ${tutedRuleViolated} (${normalizedProductName})`)
        } else {
          // Normal √ºr√ºn: %32 kuralƒ±
          tutedDiscountedPrice = tutedPrice.list_price * 0.32
          tutedRuleViolated = invoiceProduct.unit_price > tutedDiscountedPrice
          console.log(`üìä NORMAL TUTED Kontrol: ${invoiceProduct.unit_price} > ${tutedDiscountedPrice} = ${tutedRuleViolated}`)
        }
      }

      // ABB Kuralƒ±: birim_fiyati ‚â§ abb_max_price √ó 1.10 (10% artƒ±≈ü)
      if (abbPrice) {
        abbMarkupPrice = abbPrice.max_price * 1.10
        abbRuleViolated = invoiceProduct.unit_price > abbMarkupPrice
        console.log(`üìä ABB Kontrol: ${invoiceProduct.unit_price} > ${abbMarkupPrice} = ${abbRuleViolated}`)
      }

      // Manuel onay sadece ger√ßekten gerektiƒüinde
      const needsManualReview = !stockMapping || (!tutedPrice && !abbPrice)
      let problemType = ''
      
      if (!stockMapping) {
        problemType = 'no_mapping'
      } else if (!tutedPrice && !abbPrice) {
        problemType = 'both_missing'
      }
      
      // Manuel onay kontrol√º tamamlandƒ±
      
      // Tek fiyat eksikse de devam et - otomatik i≈üle
      if (!needsManualReview && (!tutedPrice || !abbPrice)) {
        if (!tutedPrice) {
          console.log(`‚ö†Ô∏è TUTED fiyatƒ± yok ama ABB var, sadece ABB kuralƒ± kontrol edilecek: ${gloriaProductName}`)
        }
        if (!abbPrice) {
          console.log(`‚ö†Ô∏è ABB fiyatƒ± yok ama TUTED var, sadece TUTED kuralƒ± kontrol edilecek: ${gloriaProductName}`)
        }
      }

      if (needsManualReview) {
        // Manuel onay gereken √ºr√ºnleri pending_manual_reviews tablosuna ekle
        console.log(`‚ö†Ô∏è Manuel onay gerekli: ${invoiceProduct.product_code} - ${problemType}`)
        
        // Basit problem detaylarƒ±
        const problemDetails = {
          analysis: problemType === 'no_mapping' ? 'Stock mapping bulunamadƒ±' : 
                   'Her iki fiyat da bulunamadƒ± - manuel kontrol gerekli'
        }
        
        // Pending review'a ekle (sonradan batch insert yapacaƒüƒ±z)
        results.push({
          invoice_product: invoiceProduct,
          stock_mapping: stockMapping,
          tuted_price: tutedPrice || undefined,
          abb_price: abbPrice || undefined,
          normalized_product_name: normalizedProductName,
          tuted_discounted_price: tutedDiscountedPrice,
          abb_markup_price: abbMarkupPrice,
          tuted_rule_violated: false,
          abb_rule_violated: false,
          refund_required: false,
          refund_amount: 0,
          warning_only: false,
          price_difference: 0,
          status: 'PENDING_MANUAL_REVIEW',
          needs_manual_review: true,
          problem_type: problemType,
          confidence_details: problemDetails
        })
        continue
      }

      // Normal otomatik hesaplama (e≈üle≈üme varsa)
      // Herhangi bir kural ihlali varsa iade gerekli
      const refundRequired = tutedRuleViolated || abbRuleViolated
      
      let refundAmount = 0
      let priceDifference = 0

      if (refundRequired) {
        // ƒ∞ade hesaplama √∂nceliƒüi: ABB > TUTED
        if (abbRuleViolated && abbMarkupPrice) {
          refundAmount = invoiceProduct.total_amount - (abbMarkupPrice * invoiceProduct.quantity)
          priceDifference = invoiceProduct.unit_price - abbMarkupPrice
        } else if (tutedRuleViolated && tutedDiscountedPrice) {
          refundAmount = invoiceProduct.total_amount - (tutedDiscountedPrice * invoiceProduct.quantity)
          priceDifference = invoiceProduct.unit_price - tutedDiscountedPrice
        }
      }

      // Status artƒ±k sadece COMPLIANT veya REFUND_REQUIRED
      // Herhangi bir kural ihlali varsa iade gerekli

      results.push({
        invoice_product: invoiceProduct,
        stock_mapping: stockMapping,
        tuted_price: tutedPrice || undefined,
        abb_price: abbPrice || undefined,
        normalized_product_name: normalizedProductName,
        tuted_discounted_price: tutedDiscountedPrice,
        abb_markup_price: abbMarkupPrice,
        tuted_rule_violated: tutedRuleViolated,
        abb_rule_violated: abbRuleViolated,
        refund_required: refundRequired,
        refund_amount: Math.max(0, refundAmount),
        warning_only: false, // Artƒ±k kullanƒ±lmƒ±yor - her ihlal iade
        price_difference: priceDifference,
        status: refundRequired ? 'REFUND_REQUIRED' : 'COMPLIANT',
        needs_manual_review: false
      })

              // √úr√ºn kontrol sonucu hesaplandƒ±
    }

    // Sonu√ßlarƒ± ayƒ±r: Otomatik vs Manuel Onay Gereken
    // Sonu√ßlar ayrƒ±lƒ±yor...
    
    const automaticResults = results.filter(r => !r.needs_manual_review)
    const manualReviewResults = results.filter(r => r.needs_manual_review)
    
    console.log(`‚úÖ Otomatik: ${automaticResults.length}, ‚ö†Ô∏è Manuel: ${manualReviewResults.length}`)

    // Otomatik sonu√ßlarƒ± price_comparisons'a kaydet
    console.log('üíæ Otomatik sonu√ßlar price_comparisons tablosuna kaydediliyor...')
    
    const today = new Date().toISOString().split('T')[0]
    const priceComparisonData = automaticResults.map(result => ({
      invoice_id: result.invoice_product.id || null,
      invoice_number: result.invoice_product.invoice_summary?.invoice_number || `INV-${result.invoice_product.id?.slice(-8)}`,
      invoice_date: result.invoice_product.invoice_summary?.invoice_date || new Date().toISOString().split('T')[0],
      
      tedarikci_stok_kodu: result.invoice_product.product_code || 'NO-CODE',
      gloria_urun_adi: result.stock_mapping?.ikinci_item_number || null,
      gloria_stok_kodu: result.stock_mapping?.ikinci_kalite_no || null,
      
      fatura_birim_fiyati: result.invoice_product.unit_price || 0,
      fatura_miktari: result.invoice_product.quantity || 0,
      fatura_toplam_tutari: result.invoice_product.total_amount || 0,
      
      tuted_list_price: result.tuted_price?.list_price || null,
      tuted_discounted_price: result.tuted_discounted_price || null,
      tuted_rule_violated: result.tuted_rule_violated || false,
      
      abb_max_price: result.abb_price?.max_price || null,
      abb_markup_price: result.abb_markup_price || null,
      abb_rule_violated: result.abb_rule_violated || false,
      
      status: result.status || 'COMPLIANT',
      requires_refund: result.refund_required || false,
      refund_amount: result.refund_amount > 0 ? result.refund_amount : 0,
      
      comparison_date: today, // DATE formatƒ±nda (YYYY-MM-DD) unique constraint ile uyumlu
      processed_by: 'price_control_system'
    }))

    // Manuel onay gereken √ºr√ºnleri hazƒ±rla
    const pendingReviewData = manualReviewResults.map(result => ({
      invoice_id: result.invoice_product.id || null,
      invoice_number: result.invoice_product.invoice_summary?.invoice_number || `INV-${result.invoice_product.id?.slice(-8)}`,
      invoice_date: result.invoice_product.invoice_summary?.invoice_date || new Date().toISOString().split('T')[0],
      
      tedarikci_stok_kodu: result.invoice_product.product_code || 'NO-CODE',
      tedarikci_urun_adi: result.invoice_product.product_name || null,
      gloria_urun_adi: result.stock_mapping?.ikinci_item_number || null,
      gloria_stok_kodu: result.stock_mapping?.ikinci_kalite_no || null,
      
      fatura_birim_fiyati: result.invoice_product.unit_price || 0,
      fatura_miktari: result.invoice_product.quantity || 0,
      fatura_toplam_tutari: result.invoice_product.total_amount || 0,
      
      problem_type: result.problem_type || 'unknown',
      problem_details: {
        has_stock_mapping: !!result.stock_mapping,
        has_tuted_price: !!result.tuted_price,
        has_abb_price: !!result.abb_price,
        normalized_name: result.normalized_product_name
      },
      
      status: 'pending',
      priority: 'normal',
      created_by: 'price_control_system',
      metadata: {
        original_tuted_price: result.tuted_price?.list_price || null,
        original_abb_price: result.abb_price?.max_price || null,
        processing_date: new Date().toISOString()
      }
    }))

    // Database'e kaydetme i≈ülemleri
    let savedToDatabase = false
    let savedManualReviews = false

    try {
      console.log(`üóëÔ∏è Bug√ºn√ºn kayƒ±tlarƒ± temizleniyor (${today})...`)
      
      // Fatura numaralarƒ±nƒ± topla (hem otomatik hem manuel i√ßin)
      const allInvoiceNumbers = [...new Set([
        ...priceComparisonData.map(item => item.invoice_number),
        ...pendingReviewData.map(item => item.invoice_number)
      ])]
      
      // 1. Otomatik sonu√ßlar i√ßin price_comparisons temizliƒüi
      if (priceComparisonData.length > 0) {
        const { error: deleteError } = await supabaseAdmin
          .from('price_comparisons')
          .delete()
          .in('invoice_number', allInvoiceNumbers)
          .gte('comparison_date', today + 'T00:00:00')
          .lt('comparison_date', today + 'T23:59:59')
          .not('processed_by', 'like', 'manual_review_%') // √á√ñZ√úM: Manuel onaylarƒ± koruma

        if (deleteError) {
          console.log('‚ö†Ô∏è Price comparisons eski kayƒ±t silme uyarƒ±sƒ±:', deleteError.message)
        } else {
          console.log('‚úÖ Price comparisons eski kayƒ±tlar temizlendi (manuel onaylar korundu)')
        }

        // Otomatik sonu√ßlarƒ± kaydet (UPSERT ile duplicate √∂nleme)
        let insertError = null
        for (const data of priceComparisonData) {
          // Check if record already exists
          const { data: existingRecord } = await supabaseAdmin
            .from('price_comparisons')
            .select('id')
            .eq('invoice_number', data.invoice_number)
            .eq('tedarikci_stok_kodu', data.tedarikci_stok_kodu)
            .eq('comparison_date', data.comparison_date)
            .single()

          if (existingRecord) {
            // Update existing record (only if not manual)
            const { data: checkManual } = await supabaseAdmin
              .from('price_comparisons')
              .select('processed_by')
              .eq('id', existingRecord.id)
              .single()

            if (!checkManual?.processed_by?.includes('manual_review_')) {
              const { error } = await supabaseAdmin
                .from('price_comparisons')
                .update(data)
                .eq('id', existingRecord.id)
              if (error) insertError = error
            }
          } else {
            // Insert new record
            const { error } = await supabaseAdmin
              .from('price_comparisons')
              .insert([data])
            if (error) insertError = error
          }
        }

        if (insertError) {
          console.error('‚ùå Price comparisons kaydetme hatasƒ±:', insertError)
          savedToDatabase = false
        } else {
          console.log(`‚úÖ ${priceComparisonData.length} otomatik sonu√ß price_comparisons'a kaydedildi (UPSERT ile duplicate √∂nlendi)`)
          savedToDatabase = true
        }
      } else {
        savedToDatabase = true
      }

      // 2. Manuel onay gereken √ºr√ºnler i√ßin pending_manual_reviews
      if (pendingReviewData.length > 0) {
        // √á√ñZ√úM: SADECE bug√ºn√ºn aynƒ± fatura kayƒ±tlarƒ±nƒ± temizle (diƒüer g√ºnlerin verilerini koru)
        const today = new Date().toISOString().split('T')[0]
        const { error: deletePendingError } = await supabaseAdmin
          .from('pending_manual_reviews')
          .delete()
          .in('invoice_number', allInvoiceNumbers)
          .eq('status', 'pending') 
          .gte('created_at', today + 'T00:00:00') // SADECE bug√ºn√ºn kayƒ±tlarƒ±

        if (deletePendingError) {
          console.log('‚ö†Ô∏è Pending reviews eski kayƒ±t silme uyarƒ±sƒ±:', deletePendingError.message)
        } else {
          console.log('‚úÖ Pending reviews bug√ºn√ºn eski kayƒ±tlarƒ± temizlendi (diƒüer g√ºnler korundu)')
        }

        // Manuel onay verilerini kaydet (duplicate check devre dƒ±≈üƒ± - zaten upsert kullanƒ±yoruz)
        console.log('üîç Manuel onay verileri hazƒ±rlanƒ±yor...')

        const uniquePendingData = []
        for (const reviewData of pendingReviewData) {
          const key = `${reviewData.invoice_number}-${reviewData.tedarikci_stok_kodu}`
          if (!approvedProductsMap.has(key)) {
            uniquePendingData.push(reviewData)
          } else {
            console.log(`‚è≠Ô∏è Daha √∂nce onaylandƒ±ƒüƒ± i√ßin manuel onaya eklenmedi: ${reviewData.tedarikci_stok_kodu}`)
          }
        }

        if (uniquePendingData.length > 0) {
          console.log(`üíæ ${uniquePendingData.length} √ºr√ºn manuel onaya kaydediliyor...`)

          const { error: insertPendingError, data: insertedData } = await supabaseAdmin
            .from('pending_manual_reviews')
            .upsert(uniquePendingData, { 
              onConflict: 'invoice_number,tedarikci_stok_kodu',
              ignoreDuplicates: false 
            })
            .select()

          if (insertPendingError) {
            console.error('‚ùå Manuel onay kaydetme hatasƒ±:', insertPendingError.message)
            savedManualReviews = false
          } else {
            console.log(`‚úÖ ${uniquePendingData.length} √ºr√ºn manuel onaya kaydedildi`)
            savedManualReviews = true
          }
                  } else {
            console.log('‚úÖ T√ºm √ºr√ºnler daha √∂nce onaylandƒ±ƒüƒ± i√ßin pending_manual_reviews\'a ekleme yapƒ±lmadƒ±')
            savedManualReviews = true
          }
      } else {
        savedManualReviews = true
      }

    } catch (dbError) {
      console.error('‚ùå Veritabanƒ± baƒülantƒ± hatasƒ±:', dbError)
      console.log('‚ö†Ô∏è Sonu√ßlar sadece frontend\'de g√∂sterilecek, veritabanƒ±na kaydedilmedi')
      savedToDatabase = false
      savedManualReviews = false
    }

    // √ñzet istatistikler
    const summary = {
      total_products: results.length,
      automatic_processed: automaticResults.length,
      manual_review_required: manualReviewResults.length,
      previously_approved: results.filter(r => r.status === 'COMPLIANT' && approvedProductsMap.has(`${r.invoice_product.invoice_summary?.invoice_number}-${r.invoice_product.product_code}`)).length,
      compliant: results.filter(r => r.status === 'COMPLIANT').length,
      warnings: results.filter(r => r.status === 'WARNING').length,
      refunds_required: results.filter(r => r.status === 'REFUND_REQUIRED').length,
      pending_manual_review: results.filter(r => r.status === 'PENDING_MANUAL_REVIEW').length,
      total_refund_amount: automaticResults.reduce((sum, r) => sum + r.refund_amount, 0),
      products_with_mapping: results.filter(r => r.stock_mapping).length,
      products_with_tuted_price: results.filter(r => r.tuted_price).length,
      products_with_abb_price: results.filter(r => r.abb_price).length,
      products_with_special_tuted_limits: results.filter(r => 
        specialLimitsMap.has(r.normalized_product_name)
      ).length,
      saved_to_database: savedToDatabase,
      saved_manual_reviews: savedManualReviews,
      manual_review_breakdown: {
        no_mapping: manualReviewResults.filter(r => r.problem_type === 'no_mapping').length,
        no_tuted: manualReviewResults.filter(r => r.problem_type === 'no_tuted').length,
        no_abb: manualReviewResults.filter(r => r.problem_type === 'no_abb').length,
        both_missing: manualReviewResults.filter(r => r.problem_type === 'both_missing').length
      },
      confidence_analysis: {
        high_confidence_automatic: automaticResults.length, // T√ºm otomatik i≈ülemler g√ºvenilir
        total_suggestions_provided: 0, // Artƒ±k kullanƒ±lmƒ±yor
        definitely_not_found: manualReviewResults.length, // Manuel onaya giden = bulunamayan
        has_suggestions: 0 // Artƒ±k kullanƒ±lmƒ±yor
      }
    }

    // E≈üle≈ümeyen √ºr√ºnleri kaydet (sadece gerektiƒüinde)
    // await productMatcher.saveUnmatchedProducts() // DEBUG: Gerektiƒüinde a√ßƒ±labilir

    console.log('üìä Fiyat kontrol tamamlandƒ±:', summary)

    // Audit logging
    const userInfo = extractUserInfo(request)
    await auditLogger.logPriceControl({
      invoice_numbers: invoice_ids,
      ...userInfo,
      total_processed: summary.total_products,
      manual_review_count: summary.manual_review_required,
      refund_count: summary.refunds_required,
      total_refund_amount: summary.total_refund_amount
    })

    return NextResponse.json({
      success: true,
      message: 'Fiyat kontrol ba≈üarƒ±yla tamamlandƒ±',
      summary,
      results,
      processing_date: new Date().toISOString().split('T')[0],
      timestamp: new Date().toISOString()
    })

  } catch (error) {
    console.error('‚ùå Fiyat kontrol hatasƒ±:', error)
    console.error('‚ùå Stack trace:', error instanceof Error ? error.stack : 'Stack yok')
    
    return NextResponse.json({
      error: 'Fiyat kontrol hatasƒ± olu≈ütu',
      details: error instanceof Error ? error.message : 'Bilinmeyen hata',
      timestamp: new Date().toISOString(),
      debug_info: {
        error_type: error instanceof Error ? error.constructor.name : typeof error,
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : null
      }
    }, { status: 500 })
  }
} 